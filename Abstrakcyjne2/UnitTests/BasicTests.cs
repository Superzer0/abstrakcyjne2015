using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using Abstrakcyjne2.Interfaces;
using Abstrakcyjne2.Objects;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace UnitTests
{
    [TestClass]
    public class BasicTests
    {
        [TestMethod]
        public void EnumeratorValidation()
        {
            var implementedInterfaces = typeof(Tree<int>).GetInterfaces();
            Assert.IsTrue(implementedInterfaces.Contains(typeof(IEnumerable<int>)));
            var subtree = new Tree<int>(5, EnumeratorOrder.BreadthFirstSearch) { 1, 2 };
            var tree = new Tree<int>(7, EnumeratorOrder.BreadthFirstSearch) { subtree, 10, 15 };
            Assert.AreEqual(10, tree.First(i => i % 2 == 0));
            var bfs = new int[] { 7, 5, 10, 15, 1, 2 };
            var maybeBfs = tree.AsEnumerable().ToArray();
            Assert.AreEqual(bfs.Length, maybeBfs.Length);
            for (int i = 0; i < bfs.Length; i++) { Assert.AreEqual(bfs[i], maybeBfs[i]); } tree.Order = EnumeratorOrder.DepthFirstSearch; Assert.AreEqual(2, tree.First(i => i % 2 == 0));
            var dfs = new int[] { 7, 5, 1, 2, 10, 15 };
            var maybeDfs = tree.AsEnumerable().ToArray();
            Assert.AreEqual(dfs.Length, maybeDfs.Length);
            for (int i = 0; i < dfs.Length; i++)
            {
                Assert.AreEqual(dfs[i], maybeDfs[i]);
            }
        }

        [TestMethod]
        public void EnumeratorClearCode()
        {
            var allowed = typeof(IEnumerator<double>).GetMembers(BindingFlags.Public | BindingFlags.Instance).ToList();
            allowed.AddRange(typeof(IDisposable).GetMembers(BindingFlags.Public | BindingFlags.Instance).ToList());
            allowed.AddRange(typeof(IEnumerator).GetMembers(BindingFlags.Public | BindingFlags.Instance).ToList());
            allowed.AddRange(typeof(object).GetMembers(BindingFlags.Public | BindingFlags.Instance).ToList());
            allowed = allowed.Where(t => t.MemberType != MemberTypes.Constructor).ToList();
            var allowedStringized = allowed.Select(a => a.ToString());
            var checkedTypes = new Type[] {
                (new Tree<double>(7, EnumeratorOrder.BreadthFirstSearch)).GetEnumerator().GetType(),
                (new Tree<double>(7, EnumeratorOrder.DepthFirstSearch)).GetEnumerator().GetType()
            }.ToArray().Distinct()
            .Where(t => !t.Name.StartsWith("<GetEnumerator>d__")); // generated by yield return construct
            foreach (var enumeratorType in checkedTypes)
            {
                Assert.AreEqual(0, enumeratorType.GetMembers(BindingFlags.Public | BindingFlags.Static).Count(), "Public static members not allowed in enumerator types.");
                var checkedMembersStringized = enumeratorType.GetMembers(BindingFlags.Public | BindingFlags.Instance)
                    .Where(m => m.MemberType != MemberTypes.Constructor)
                    .Select(m => m.ToString());
                var shouldBeNone = checkedMembersStringized.Except(allowedStringized);
                Assert.AreEqual(0, shouldBeNone.Count(), String.Format("Invalid members: \"{0}\" in type {1}.", String.Join("\", \"", shouldBeNone), enumeratorType.FullName));
            }
        }

        [TestMethod]
        public void EnumerateWithNoChildren()
        {
            var tree = new Tree<int>(7, EnumeratorOrder.DepthFirstSearch);
            Assert.AreEqual(7, tree.AsEnumerable().First());
            tree.Order = EnumeratorOrder.BreadthFirstSearch;
            Assert.AreEqual(7, tree.AsEnumerable().First());
            var subtree = new Tree<int>(5, EnumeratorOrder.BreadthFirstSearch);
            tree.Add(subtree);
            Assert.AreEqual(5, tree.AsEnumerable().Last());
            tree.Order = EnumeratorOrder.DepthFirstSearch;
            Assert.AreEqual(5, tree.AsEnumerable().Last());
        }

        [TestMethod]
        public void OrderPropertyValidation()
        {
            var subtree = new Tree<int>(5, EnumeratorOrder.DepthFirstSearch) { 1, 2 };
            var tree = new Tree<int>(7, EnumeratorOrder.BreadthFirstSearch) {subtree};
            Assert.AreEqual(EnumeratorOrder.BreadthFirstSearch, subtree.Order);
            foreach (Tree<int> child in subtree.Children)
            {
                Assert.AreEqual(EnumeratorOrder.BreadthFirstSearch, child.Order);
            }
            subtree.Add(3);
            Assert.AreEqual(EnumeratorOrder.BreadthFirstSearch, subtree.Children.First(c => c.Value == 3).Order);
            tree.Order = EnumeratorOrder.DepthFirstSearch;
            subtree.Add(4);
            Assert.AreEqual(EnumeratorOrder.DepthFirstSearch, subtree.Children.First(c => c.Value == 4).Order);
            try
            {
                tree.Order = (EnumeratorOrder)123;
                Assert.Fail("Unknown order type defined.");
            }
            catch (ArgumentOutOfRangeException)
            {
            }
            catch (Exception)
            {
                Assert.Fail("Invalid exception type.");
            }
        }

        [TestMethod]
        public void ChildrenPropertyValidation()
        {
            var tree = new Tree<int>(7, EnumeratorOrder.BreadthFirstSearch);
            Assert.IsNotNull(tree.Children);
            var type = tree.Children.GetType();
            var editableTypes = new List<Type>()
            {
                typeof(Collection<>),
                typeof(List<>),
                typeof(Queue<>),
                typeof(Stack<>),
            }.Select(t => t.MakeGenericType(tree.GetType()));
            foreach (var et in editableTypes)
            {
                Assert.AreNotEqual(et, type);
                Assert.IsFalse(type.IsSubclassOf(et));
            }
            Expression<Func<object>> propertySelector = () => tree.Children;
            var propertyName = (propertySelector.Body as MemberExpression).Member.Name;
            var propertyInfo = tree.GetType().GetProperty(propertyName, BindingFlags.Public | BindingFlags.Instance);
            var setter = propertyInfo.GetSetMethod(false);
            Assert.IsNull(setter);
        }
    }
}
